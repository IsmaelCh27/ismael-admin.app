import { Injectable, inject } from '@angular/core';
import { NotificationService } from '@src/app/shared/services/notification-service';
import { SupabaseService } from '@src/app/shared/services/supabase-service';
import type { Technology } from './technology-service';

// create table public.projects (
//   id bigint generated by default as identity not null,
//   created_at timestamp with time zone not null default now(),
//   name character varying not null,
//   description character varying not null,
//   demo_link character varying null,
//   image_link character varying not null,
//   repository_link character varying null,
//   constraint projects_pkey primary key (id)
// ) TABLESPACE pg_default;

// create table public.technologies (
//   id bigint generated by default as identity not null,
//   created_at timestamp with time zone not null default now(),
//   name character varying not null,
//   icon_link character varying not null,
//   documentation_link character varying not null,
//   is_skill boolean not null default false,
//   constraint technologies_pkey primary key (id)
// ) TABLESPACE pg_default;

// create table public.projects_technologies (
//   id bigint generated by default as identity not null,
//   created_at timestamp with time zone not null default now(),
//   project_id bigint not null,
//   technology_id bigint not null,
//   constraint projects_technologies_pkey primary key (id),
//   constraint projects_technologies_project_id_fkey foreign KEY (project_id) references projects (id),
//   constraint projects_technologies_technology_id_fkey foreign KEY (technology_id) references technologies (id)
// ) TABLESPACE pg_default;

export interface Project {
  id: number;
  created_at: string;
  name: string;
  description: string;
  demo_link: string | null;
  image_link: string;
  repository_link: string | null;
  technologies: Technology[];
}

export interface CreateProject {
  name: string;
  description: string;
  demo_link?: string | null;
  image_link: string;
  repository_link?: string | null;
  technologies_ids?: number[];
}

export interface ProjectsTechnologies {
  id: number;
  created_at: string;
  project_id: number;
  technology_id: number;
  technologies: Technology;
}

@Injectable({
  providedIn: 'root',
})
export class ProjectService {
  private readonly supabaseService = inject(SupabaseService);
  private readonly notification = inject(NotificationService);

  /**
   * Obtener todos los proyectos con sus tecnologías
   */
  async getProjects(): Promise<Project[]> {
    try {
      const { data, error } = await this.supabaseService
        .from('projects')
        .select('*, projects_technologies(technologies(*))')
        .order('name', { ascending: true });

      if (error) {
        throw new Error(error.message);
      }

      // Mapear la respuesta para aplanar la estructura
      const projects = (data || []).map((project) => ({
        ...project,

        technologies:
          project.projects_technologies?.map(
            (pt: ProjectsTechnologies) => pt.technologies,
          ) || [],
      }));

      return projects;
    } catch (error) {
      this.notification.error(
        'Error',
        `Error al obtener los proyectos: ${
          (error as { message?: string })?.message ?? 'Error desconocido'
        }`,
      );
      throw error;
    }
  }

  /**
   * Crear nuevo proyecto con tecnologías
   */
  async createProject(project: CreateProject): Promise<Project> {
    try {
      // 1. Crear el proyecto
      const { technologies_ids, ...projectData } = project;

      const { data: newProject, error: projectError } =
        await this.supabaseService
          .from('projects')
          .insert([projectData])
          .select()
          .single();

      if (projectError) throw new Error(projectError.message);

      // 2. Asociar tecnologías si existen
      if (technologies_ids && technologies_ids.length > 0) {
        const relations = technologies_ids.map((techId) => ({
          project_id: newProject.id,
          technology_id: techId,
        }));

        const { error: relationError } = await this.supabaseService
          .from('projects_technologies')
          .insert(relations);

        if (relationError) throw new Error(relationError.message);
      }

      this.notification.success('Éxito', 'Proyecto creado con éxito.');
      return newProject;
    } catch (error) {
      throw new Error(
        `Error al crear proyecto: ${
          (error as { message?: string })?.message ?? 'Error desconocido'
        }`,
      );
    }
  }

  /**
   * Actualizar proyecto existente y sus tecnologías
   */
  async updateProject(
    id: number,
    project: Partial<CreateProject>,
  ): Promise<Project> {
    try {
      const { technologies_ids, ...projectData } = project;

      // 1. Actualizar datos del proyecto
      const { data: updatedProject, error: projectError } =
        await this.supabaseService
          .from('projects')
          .update(projectData)
          .eq('id', id)
          .select()
          .single();

      if (projectError) throw new Error(projectError.message);

      // 2. Actualizar tecnologías si se proporcionan
      if (technologies_ids !== undefined) {
        // Primero eliminar relaciones existentes
        const { error: deleteError } = await this.supabaseService
          .from('projects_technologies')
          .delete()
          .eq('project_id', id);

        if (deleteError) throw new Error(deleteError.message);

        // Insertar nuevas relaciones si hay IDs
        if (technologies_ids.length > 0) {
          const relations = technologies_ids.map((techId) => ({
            project_id: id,
            technology_id: techId,
          }));

          const { error: insertError } = await this.supabaseService
            .from('projects_technologies')
            .insert(relations);

          if (insertError) throw new Error(insertError.message);
        }
      }

      this.notification.success('Éxito', 'Proyecto actualizado con éxito.');
      return updatedProject;
    } catch (error) {
      throw new Error(
        `Error al actualizar proyecto: ${
          (error as { message?: string })?.message ?? 'Error desconocido'
        }`,
      );
    }
  }

  /**
   * Eliminar proyecto
   */
  async deleteProject(id: number): Promise<void> {
    try {
      const { error } = await this.supabaseService
        .from('projects')
        .delete()
        .eq('id', id);

      if (error) {
        throw new Error(error.message);
      }

      this.notification.success('Éxito', 'Proyecto eliminada con éxito.');
    } catch (error) {
      throw new Error(
        `Error al eliminar proyecto: ${
          (error as { message?: string })?.message ?? 'Error desconocido'
        }`,
      );
    }
  }
}
